{"ast":null,"code":"/**\n * @sgratzl/chartjs-chart-boxplot\n * https://github.com/sgratzl/chartjs-chart-boxplot\n *\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('chart.js'), require('chart.js/helpers')) : typeof define === 'function' && define.amd ? define(['exports', 'chart.js', 'chart.js/helpers'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ChartBoxPlot = {}, global.Chart, global.Chart.helpers));\n})(this, function (exports, chart_js, helpers) {\n  'use strict';\n  /**\n   * @sgratzl/boxplots\n   * https://github.com/sgratzl/boxplots\n   *\n   * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\n   */\n\n  const HELPER = Math.sqrt(2 * Math.PI);\n\n  function gaussian(u) {\n    return Math.exp(-0.5 * u * u) / HELPER;\n  }\n\n  function toSampleVariance(variance, len) {\n    return variance * len / (len - 1);\n  }\n\n  function nrd(iqr, variance, len) {\n    let s = Math.sqrt(toSampleVariance(variance, len));\n\n    if (typeof iqr === 'number') {\n      s = Math.min(s, iqr / 1.34);\n    }\n\n    return 1.06 * s * Math.pow(len, -0.2);\n  }\n\n  function kde(stats) {\n    const len = stats.items.length;\n    const bandwidth = nrd(stats.iqr, stats.variance, len);\n    return x => {\n      let i = 0;\n      let sum = 0;\n\n      for (i = 0; i < len; i++) {\n        const v = stats.items[i];\n        sum += gaussian((x - v) / bandwidth);\n      }\n\n      return sum / bandwidth / len;\n    };\n  }\n\n  function quantilesInterpolate(arr, length, interpolate) {\n    const n1 = length - 1;\n\n    const compute = q => {\n      const index = q * n1;\n      const lo = Math.floor(index);\n      const h = index - lo;\n      const a = arr[lo];\n      return h === 0 ? a : interpolate(a, arr[Math.min(lo + 1, n1)], h);\n    };\n\n    return {\n      q1: compute(0.25),\n      median: compute(0.5),\n      q3: compute(0.75)\n    };\n  }\n\n  function quantilesType7(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesInterpolate(arr, length, (a, b, alpha) => a + alpha * (b - a));\n  }\n\n  function quantilesLinear(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesInterpolate(arr, length, (i, j, fraction) => i + (j - i) * fraction);\n  }\n\n  function quantilesLower(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesInterpolate(arr, length, i => i);\n  }\n\n  function quantilesHigher(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesInterpolate(arr, length, (_, j) => j);\n  }\n\n  function quantilesNearest(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesInterpolate(arr, length, (i, j, fraction) => fraction < 0.5 ? i : j);\n  }\n\n  function quantilesMidpoint(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesInterpolate(arr, length, (i, j) => (i + j) * 0.5);\n  }\n\n  function quantilesFivenum(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    const n = length;\n    const n4 = Math.floor((n + 3) / 2) / 2;\n\n    const compute = d => 0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);\n\n    return {\n      q1: compute(n4),\n      median: compute((n + 1) / 2),\n      q3: compute(n + 1 - n4)\n    };\n  }\n\n  function quantilesHinges(arr) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;\n    return quantilesFivenum(arr, length);\n  }\n\n  function createSortedData(data) {\n    let valid = 0;\n    const {\n      length\n    } = data;\n    const vs = data instanceof Float64Array ? new Float64Array(length) : new Float32Array(length);\n\n    for (let i = 0; i < length; i += 1) {\n      const v = data[i];\n\n      if (v == null || Number.isNaN(v)) {\n        continue;\n      }\n\n      vs[valid] = v;\n      valid += 1;\n    }\n\n    const missing = length - valid;\n\n    if (valid === 0) {\n      return {\n        min: Number.NaN,\n        max: Number.NaN,\n        missing,\n        s: []\n      };\n    }\n\n    const validData = valid === length ? vs : vs.subarray(0, valid);\n    validData.sort((a, b) => a === b ? 0 : a < b ? -1 : 1);\n    const min = validData[0];\n    const max = validData[validData.length - 1];\n    return {\n      min,\n      max,\n      missing,\n      s: validData\n    };\n  }\n\n  function withSortedData(data) {\n    if (data.length === 0) {\n      return {\n        min: Number.NaN,\n        max: Number.NaN,\n        missing: 0,\n        s: []\n      };\n    }\n\n    const min = data[0];\n    const max = data[data.length - 1];\n    return {\n      min,\n      max,\n      missing: 0,\n      s: data\n    };\n  }\n\n  function computeWhiskers(s, valid, min, max, _ref) {\n    let {\n      eps,\n      quantiles,\n      coef,\n      whiskersMode\n    } = _ref;\n\n    const same = (a, b) => Math.abs(a - b) < eps;\n\n    const {\n      median,\n      q1,\n      q3\n    } = quantiles(s, valid);\n    const iqr = q3 - q1;\n    const isCoefValid = typeof coef === 'number' && coef > 0;\n    let whiskerLow = isCoefValid ? Math.max(min, q1 - coef * iqr) : min;\n    let whiskerHigh = isCoefValid ? Math.min(max, q3 + coef * iqr) : max;\n    const outlierLow = [];\n\n    for (let i = 0; i < valid; i += 1) {\n      const v = s[i];\n\n      if (v >= whiskerLow || same(v, whiskerLow)) {\n        if (whiskersMode === 'nearest') {\n          whiskerLow = v;\n        }\n\n        break;\n      }\n\n      if (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v)) {\n        outlierLow.push(v);\n      }\n    }\n\n    const reversedOutlierHigh = [];\n\n    for (let i = valid - 1; i >= 0; i -= 1) {\n      const v = s[i];\n\n      if (v <= whiskerHigh || same(v, whiskerHigh)) {\n        if (whiskersMode === 'nearest') {\n          whiskerHigh = v;\n        }\n\n        break;\n      }\n\n      if ((reversedOutlierHigh.length === 0 || !same(reversedOutlierHigh[reversedOutlierHigh.length - 1], v)) && (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v))) {\n        reversedOutlierHigh.push(v);\n      }\n    }\n\n    const outlier = outlierLow.concat(reversedOutlierHigh.reverse());\n    return {\n      median,\n      q1,\n      q3,\n      iqr,\n      outlier,\n      whiskerHigh,\n      whiskerLow\n    };\n  }\n\n  function computeStats(s, valid) {\n    let mean = 0;\n\n    for (let i = 0; i < valid; i++) {\n      const v = s[i];\n      mean += v;\n    }\n\n    mean /= valid;\n    let variance = 0;\n\n    for (let i = 0; i < valid; i++) {\n      const v = s[i];\n      variance += (v - mean) * (v - mean);\n    }\n\n    variance /= valid;\n    return {\n      mean,\n      variance\n    };\n  }\n\n  function boxplot(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const fullOptions = {\n      coef: 1.5,\n      eps: 10e-3,\n      quantiles: quantilesType7,\n      validAndSorted: false,\n      whiskersMode: 'nearest',\n      ...options\n    };\n    const {\n      missing,\n      s,\n      min,\n      max\n    } = fullOptions.validAndSorted ? withSortedData(data) : createSortedData(data);\n    const invalid = {\n      min: Number.NaN,\n      max: Number.NaN,\n      mean: Number.NaN,\n      missing,\n      iqr: Number.NaN,\n      count: data.length,\n      whiskerHigh: Number.NaN,\n      whiskerLow: Number.NaN,\n      outlier: [],\n      median: Number.NaN,\n      q1: Number.NaN,\n      q3: Number.NaN,\n      variance: 0,\n      items: [],\n      kde: () => 0\n    };\n    const valid = data.length - missing;\n\n    if (valid === 0) {\n      return invalid;\n    }\n\n    const result = {\n      min,\n      max,\n      count: data.length,\n      missing,\n      items: s,\n      ...computeStats(s, valid),\n      ...computeWhiskers(s, valid, min, max, fullOptions)\n    };\n    return { ...result,\n      kde: kde(result)\n    };\n  }\n\n  function whiskers(boxplot, arr) {\n    let coef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;\n    const iqr = boxplot.q3 - boxplot.q1;\n    const coefValid = typeof coef === 'number' && coef > 0;\n    let whiskerMin = coefValid ? Math.max(boxplot.min, boxplot.q1 - coef * iqr) : boxplot.min;\n    let whiskerMax = coefValid ? Math.min(boxplot.max, boxplot.q3 + coef * iqr) : boxplot.max;\n\n    if (Array.isArray(arr)) {\n      for (let i = 0; i < arr.length; i += 1) {\n        const v = arr[i];\n\n        if (v >= whiskerMin) {\n          whiskerMin = v;\n          break;\n        }\n      }\n\n      for (let i = arr.length - 1; i >= 0; i -= 1) {\n        const v = arr[i];\n\n        if (v <= whiskerMax) {\n          whiskerMax = v;\n          break;\n        }\n      }\n    }\n\n    return {\n      whiskerMin,\n      whiskerMax\n    };\n  }\n\n  const defaultStatsOptions = {\n    coef: 1.5,\n    quantiles: 7\n  };\n\n  function determineQuantiles(q) {\n    if (typeof q === 'function') {\n      return q;\n    }\n\n    const lookup = {\n      hinges: quantilesHinges,\n      fivenum: quantilesFivenum,\n      7: quantilesType7,\n      quantiles: quantilesType7,\n      linear: quantilesLinear,\n      lower: quantilesLower,\n      higher: quantilesHigher,\n      nearest: quantilesNearest,\n      midpoint: quantilesMidpoint\n    };\n    return lookup[q] || quantilesType7;\n  }\n\n  function determineStatsOptions(options) {\n    const coef = options == null || typeof options.coef !== 'number' ? defaultStatsOptions.coef : options.coef;\n    const q = options == null || options.quantiles == null ? quantilesType7 : options.quantiles;\n    const quantiles = determineQuantiles(q);\n    return {\n      coef,\n      quantiles\n    };\n  }\n\n  function boxplotStats(arr, options) {\n    const r = boxplot(arr, determineStatsOptions(options));\n    return {\n      items: Array.from(r.items),\n      outliers: r.outlier,\n      whiskerMax: r.whiskerHigh,\n      whiskerMin: r.whiskerLow,\n      max: r.max,\n      median: r.median,\n      mean: r.mean,\n      min: r.min,\n      q1: r.q1,\n      q3: r.q3\n    };\n  }\n\n  function computeSamples(min, max, points) {\n    const range = max - min;\n    const samples = [];\n    const inc = range / points;\n\n    for (let v = min; v <= max && inc > 0; v += inc) {\n      samples.push(v);\n    }\n\n    if (samples[samples.length - 1] !== max) {\n      samples.push(max);\n    }\n\n    return samples;\n  }\n\n  function violinStats(arr, options) {\n    if (arr.length === 0) {\n      return undefined;\n    }\n\n    const stats = boxplot(arr, determineStatsOptions(options));\n    const samples = computeSamples(stats.min, stats.max, options.points);\n    const coords = samples.map(v => ({\n      v,\n      estimate: stats.kde(v)\n    }));\n    const maxEstimate = coords.reduce((a, d) => Math.max(a, d.estimate), Number.NEGATIVE_INFINITY);\n    return {\n      max: stats.max,\n      min: stats.min,\n      mean: stats.mean,\n      median: stats.median,\n      q1: stats.q1,\n      q3: stats.q3,\n      items: Array.from(stats.items),\n      coords,\n      outliers: [],\n      maxEstimate\n    };\n  }\n\n  function asBoxPlotStats(value, options) {\n    if (!value) {\n      return undefined;\n    }\n\n    if (typeof value.median === 'number' && typeof value.q1 === 'number' && typeof value.q3 === 'number') {\n      if (typeof value.whiskerMin === 'undefined') {\n        const {\n          coef\n        } = determineStatsOptions(options);\n        const {\n          whiskerMin,\n          whiskerMax\n        } = whiskers(value, Array.isArray(value.items) ? value.items.slice().sort((a, b) => a - b) : null, coef);\n        value.whiskerMin = whiskerMin;\n        value.whiskerMax = whiskerMax;\n      }\n\n      return value;\n    }\n\n    if (!Array.isArray(value)) {\n      return undefined;\n    }\n\n    return boxplotStats(value, options);\n  }\n\n  function asViolinStats(value, options) {\n    if (!value) {\n      return undefined;\n    }\n\n    if (typeof value.median === 'number' && Array.isArray(value.coords)) {\n      return value;\n    }\n\n    if (!Array.isArray(value)) {\n      return undefined;\n    }\n\n    return violinStats(value, options);\n  }\n\n  function rnd() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n    let s = seed;\n    return () => {\n      s = (s * 9301 + 49297) % 233280;\n      return s / 233280;\n    };\n  }\n\n  const interpolators = {\n    number(from, to, factor) {\n      if (from === to) {\n        return to;\n      }\n\n      if (from == null) {\n        return to;\n      }\n\n      if (to == null) {\n        return from;\n      }\n\n      return from + (to - from) * factor;\n    }\n\n  };\n\n  function interpolateNumberArray(from, to, factor) {\n    if (typeof from === 'number' && typeof to === 'number') {\n      return interpolators.number(from, to, factor);\n    }\n\n    if (Array.isArray(from) && Array.isArray(to)) {\n      return to.map((t, i) => interpolators.number(from[i], t, factor));\n    }\n\n    return to;\n  }\n\n  function interpolateKdeCoords(from, to, factor) {\n    if (Array.isArray(from) && Array.isArray(to)) {\n      return to.map((t, i) => ({\n        v: interpolators.number(from[i] ? from[i].v : null, t.v, factor),\n        estimate: interpolators.number(from[i] ? from[i].estimate : null, t.estimate, factor)\n      }));\n    }\n\n    return to;\n  }\n\n  function patchInHoveredOutlier(item) {\n    const value = item.formattedValue;\n    const that = this;\n\n    if (value && that._tooltipOutlier != null && item.datasetIndex === that._tooltipOutlier.datasetIndex) {\n      value.hoveredOutlierIndex = that._tooltipOutlier.index;\n    }\n  }\n\n  function outlierPositioner(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = 0;\n    let y = 0;\n    let count = 0;\n\n    for (let i = 0; i < items.length; i += 1) {\n      const el = items[i].element;\n\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition(eventPosition, this);\n        x += pos.x;\n        y += pos.y;\n        count += 1;\n      }\n    }\n\n    return {\n      x: x / count,\n      y: y / count\n    };\n  }\n\n  outlierPositioner.id = 'average';\n\n  outlierPositioner.register = () => {\n    chart_js.Tooltip.positioners.average = outlierPositioner;\n    return outlierPositioner;\n  };\n\n  function baseDefaults$1(keys) {\n    const colorKeys = ['borderColor', 'backgroundColor'].concat(keys.filter(c => c.endsWith('Color')));\n    return {\n      animations: {\n        numberArray: {\n          fn: interpolateNumberArray,\n          properties: ['outliers', 'items']\n        },\n        colors: {\n          type: 'color',\n          properties: colorKeys\n        }\n      },\n      transitions: {\n        show: {\n          animations: {\n            colors: {\n              type: 'color',\n              properties: colorKeys,\n              from: 'transparent'\n            }\n          }\n        },\n        hide: {\n          animations: {\n            colors: {\n              type: 'color',\n              properties: colorKeys,\n              to: 'transparent'\n            }\n          }\n        }\n      },\n      minStats: 'min',\n      maxStats: 'max',\n      ...defaultStatsOptions\n    };\n  }\n\n  function defaultOverrides() {\n    return {\n      plugins: {\n        tooltip: {\n          position: outlierPositioner.register().id,\n          callbacks: {\n            beforeLabel: patchInHoveredOutlier\n          }\n        }\n      }\n    };\n  }\n\n  class StatsBase$1 extends chart_js.BarController {\n    _transformStats(target, source, mapper) {\n      for (const key of ['min', 'max', 'median', 'q3', 'q1', 'mean']) {\n        const v = source[key];\n\n        if (typeof v === 'number') {\n          target[key] = mapper(v);\n        }\n      }\n\n      for (const key of ['outliers', 'items']) {\n        if (Array.isArray(source[key])) {\n          target[key] = source[key].map(mapper);\n        }\n      }\n    }\n\n    getMinMax(scale, canStack) {\n      const bak = scale.axis;\n      const config = this.options;\n      scale.axis = config.minStats;\n      const {\n        min\n      } = super.getMinMax(scale, canStack);\n      scale.axis = config.maxStats;\n      const {\n        max\n      } = super.getMinMax(scale, canStack);\n      scale.axis = bak;\n      return {\n        min,\n        max\n      };\n    }\n\n    parsePrimitiveData(meta, data, start, count) {\n      const vScale = meta.vScale;\n      const iScale = meta.iScale;\n      const labels = iScale.getLabels();\n      const r = [];\n\n      for (let i = 0; i < count; i += 1) {\n        const index = i + start;\n        const parsed = {};\n        parsed[iScale.axis] = iScale.parse(labels[index], index);\n\n        const stats = this._parseStats(data == null ? null : data[index], this.options);\n\n        if (stats) {\n          Object.assign(parsed, stats);\n          parsed[vScale.axis] = stats.median;\n        }\n\n        r.push(parsed);\n      }\n\n      return r;\n    }\n\n    parseArrayData(meta, data, start, count) {\n      return this.parsePrimitiveData(meta, data, start, count);\n    }\n\n    parseObjectData(meta, data, start, count) {\n      return this.parsePrimitiveData(meta, data, start, count);\n    }\n\n    getLabelAndValue(index) {\n      const r = super.getLabelAndValue(index);\n      const {\n        vScale\n      } = this._cachedMeta;\n      const parsed = this.getParsed(index);\n\n      if (!vScale || !parsed || r.value === 'NaN') {\n        return r;\n      }\n\n      r.value = {\n        raw: parsed,\n        hoveredOutlierIndex: -1\n      };\n\n      this._transformStats(r.value, parsed, v => vScale.getLabelForValue(v));\n\n      const s = this._toStringStats(r.value.raw);\n\n      r.value.toString = function toString() {\n        if (this.hoveredOutlierIndex >= 0) {\n          return `(outlier: ${this.outliers[this.hoveredOutlierIndex]})`;\n        }\n\n        return s;\n      };\n\n      return r;\n    }\n\n    _toStringStats(b) {\n      const f = v => v == null ? 'NaN' : helpers.formatNumber(v, this.chart.options.locale, {});\n\n      return `(min: ${f(b.min)}, 25% quantile: ${f(b.q1)}, median: ${f(b.median)}, mean: ${f(b.mean)}, 75% quantile: ${f(b.q3)}, max: ${f(b.max)})`;\n    }\n\n    updateElement(rectangle, index, properties, mode) {\n      const reset = mode === 'reset';\n      const scale = this._cachedMeta.vScale;\n      const parsed = this.getParsed(index);\n      const base = scale.getBasePixel();\n      properties._datasetIndex = this.index;\n      properties._index = index;\n\n      this._transformStats(properties, parsed, v => reset ? base : scale.getPixelForValue(v, index));\n\n      super.updateElement(rectangle, index, properties, mode);\n    }\n\n  }\n\n  const baseDefaults = {\n    borderWidth: 1,\n    outlierStyle: 'circle',\n    outlierRadius: 2,\n    outlierBorderWidth: 1,\n    itemStyle: 'circle',\n    itemRadius: 0,\n    itemBorderWidth: 0,\n    meanStyle: 'circle',\n    meanRadius: 3,\n    meanBorderWidth: 1,\n    hitPadding: 2,\n    outlierHitRadius: 4\n  };\n  const baseRoutes = {\n    outlierBackgroundColor: 'backgroundColor',\n    outlierBorderColor: 'borderColor',\n    itemBackgroundColor: 'backgroundColor',\n    itemBorderColor: 'borderColor',\n    meanBackgroundColor: 'backgroundColor',\n    meanBorderColor: 'borderColor'\n  };\n\n  const baseOptionKeys = (() => Object.keys(baseDefaults).concat(Object.keys(baseRoutes)))();\n\n  class StatsBase extends chart_js.Element {\n    isVertical() {\n      return !this.horizontal;\n    }\n\n    _drawItems(ctx) {\n      const vert = this.isVertical();\n      const props = this.getProps(['x', 'y', 'items', 'width', 'height', 'outliers']);\n      const {\n        options\n      } = this;\n\n      if (options.itemRadius <= 0 || !props.items || props.items.length <= 0) {\n        return;\n      }\n\n      ctx.save();\n      ctx.strokeStyle = options.itemBorderColor;\n      ctx.fillStyle = options.itemBackgroundColor;\n      ctx.lineWidth = options.itemBorderWidth;\n      const random = rnd(this._datasetIndex * 1000 + this._index);\n      const pointOptions = {\n        pointStyle: options.itemStyle,\n        radius: options.itemRadius,\n        borderWidth: options.itemBorderWidth\n      };\n      const outliers = new Set(props.outliers || []);\n\n      if (vert) {\n        props.items.forEach(v => {\n          if (!outliers.has(v)) {\n            helpers.drawPoint(ctx, pointOptions, props.x - props.width / 2 + random() * props.width, v);\n          }\n        });\n      } else {\n        props.items.forEach(v => {\n          if (!outliers.has(v)) {\n            helpers.drawPoint(ctx, pointOptions, v, props.y - props.height / 2 + random() * props.height);\n          }\n        });\n      }\n\n      ctx.restore();\n    }\n\n    _drawOutliers(ctx) {\n      const vert = this.isVertical();\n      const props = this.getProps(['x', 'y', 'outliers']);\n      const {\n        options\n      } = this;\n\n      if (options.outlierRadius <= 0 || !props.outliers || props.outliers.length === 0) {\n        return;\n      }\n\n      ctx.save();\n      ctx.fillStyle = options.outlierBackgroundColor;\n      ctx.strokeStyle = options.outlierBorderColor;\n      ctx.lineWidth = options.outlierBorderWidth;\n      const pointOptions = {\n        pointStyle: options.outlierStyle,\n        radius: options.outlierRadius,\n        borderWidth: options.outlierBorderWidth\n      };\n\n      if (vert) {\n        props.outliers.forEach(v => {\n          helpers.drawPoint(ctx, pointOptions, props.x, v);\n        });\n      } else {\n        props.outliers.forEach(v => {\n          helpers.drawPoint(ctx, pointOptions, v, props.y);\n        });\n      }\n\n      ctx.restore();\n    }\n\n    _drawMeanDot(ctx) {\n      const vert = this.isVertical();\n      const props = this.getProps(['x', 'y', 'mean']);\n      const {\n        options\n      } = this;\n\n      if (options.meanRadius <= 0 || props.mean == null || Number.isNaN(props.mean)) {\n        return;\n      }\n\n      ctx.save();\n      ctx.fillStyle = options.meanBackgroundColor;\n      ctx.strokeStyle = options.meanBorderColor;\n      ctx.lineWidth = options.meanBorderWidth;\n      const pointOptions = {\n        pointStyle: options.meanStyle,\n        radius: options.meanRadius,\n        borderWidth: options.meanBorderWidth\n      };\n\n      if (vert) {\n        helpers.drawPoint(ctx, pointOptions, props.x, props.mean);\n      } else {\n        helpers.drawPoint(ctx, pointOptions, props.mean, props.y);\n      }\n\n      ctx.restore();\n    }\n\n    _getBounds(_useFinalPosition) {\n      return {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n\n    _getHitBounds(useFinalPosition) {\n      const padding = this.options.hitPadding;\n\n      const b = this._getBounds(useFinalPosition);\n\n      return {\n        left: b.left - padding,\n        top: b.top - padding,\n        right: b.right + padding,\n        bottom: b.bottom + padding\n      };\n    }\n\n    inRange(mouseX, mouseY, useFinalPosition) {\n      if (Number.isNaN(this.x) && Number.isNaN(this.y)) {\n        return false;\n      }\n\n      return this._boxInRange(mouseX, mouseY, useFinalPosition) || this._outlierIndexInRange(mouseX, mouseY, useFinalPosition) >= 0;\n    }\n\n    inXRange(mouseX, useFinalPosition) {\n      const bounds = this._getHitBounds(useFinalPosition);\n\n      return mouseX >= bounds.left && mouseX <= bounds.right;\n    }\n\n    inYRange(mouseY, useFinalPosition) {\n      const bounds = this._getHitBounds(useFinalPosition);\n\n      return mouseY >= bounds.top && mouseY <= bounds.bottom;\n    }\n\n    _outlierIndexInRange(mouseX, mouseY, useFinalPosition) {\n      const props = this.getProps(['x', 'y'], useFinalPosition);\n      const hitRadius = this.options.outlierHitRadius;\n\n      const outliers = this._getOutliers(useFinalPosition);\n\n      const vertical = this.isVertical();\n\n      if (vertical && Math.abs(mouseX - props.x) > hitRadius || !vertical && Math.abs(mouseY - props.y) > hitRadius) {\n        return -1;\n      }\n\n      const toCompare = vertical ? mouseY : mouseX;\n\n      for (let i = 0; i < outliers.length; i += 1) {\n        if (Math.abs(outliers[i] - toCompare) <= hitRadius) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    _boxInRange(mouseX, mouseY, useFinalPosition) {\n      const bounds = this._getHitBounds(useFinalPosition);\n\n      return mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n    }\n\n    getCenterPoint(useFinalPosition) {\n      const props = this.getProps(['x', 'y'], useFinalPosition);\n      return {\n        x: props.x,\n        y: props.y\n      };\n    }\n\n    _getOutliers(useFinalPosition) {\n      const props = this.getProps(['outliers'], useFinalPosition);\n      return props.outliers || [];\n    }\n\n    tooltipPosition(eventPosition, tooltip) {\n      if (!eventPosition || typeof eventPosition === 'boolean') {\n        return this.getCenterPoint();\n      }\n\n      if (tooltip) {\n        delete tooltip._tooltipOutlier;\n      }\n\n      const props = this.getProps(['x', 'y']);\n\n      const index = this._outlierIndexInRange(eventPosition.x, eventPosition.y);\n\n      if (index < 0 || !tooltip) {\n        return this.getCenterPoint();\n      }\n\n      tooltip._tooltipOutlier = {\n        index,\n        datasetIndex: this._datasetIndex\n      };\n\n      if (this.isVertical()) {\n        return {\n          x: props.x,\n          y: this._getOutliers()[index]\n        };\n      }\n\n      return {\n        x: this._getOutliers()[index],\n        y: props.y\n      };\n    }\n\n  }\n\n  const boxOptionsKeys = baseOptionKeys.concat(['medianColor', 'lowerBackgroundColor']);\n\n  class BoxAndWiskers extends StatsBase {\n    draw(ctx) {\n      ctx.save();\n      ctx.fillStyle = this.options.backgroundColor;\n      ctx.strokeStyle = this.options.borderColor;\n      ctx.lineWidth = this.options.borderWidth;\n\n      this._drawBoxPlot(ctx);\n\n      this._drawOutliers(ctx);\n\n      this._drawMeanDot(ctx);\n\n      ctx.restore();\n\n      this._drawItems(ctx);\n    }\n\n    _drawBoxPlot(ctx) {\n      if (this.isVertical()) {\n        this._drawBoxPlotVertical(ctx);\n      } else {\n        this._drawBoxPlotHorizontal(ctx);\n      }\n    }\n\n    _drawBoxPlotVertical(ctx) {\n      const {\n        options\n      } = this;\n      const props = this.getProps(['x', 'width', 'q1', 'q3', 'median', 'whiskerMin', 'whiskerMax']);\n      const {\n        x\n      } = props;\n      const {\n        width\n      } = props;\n      const x0 = x - width / 2;\n\n      if (props.q3 > props.q1) {\n        ctx.fillRect(x0, props.q1, width, props.q3 - props.q1);\n      } else {\n        ctx.fillRect(x0, props.q3, width, props.q1 - props.q3);\n      }\n\n      ctx.save();\n\n      if (options.medianColor && options.medianColor !== 'transparent' && options.medianColor !== '#0000') {\n        ctx.strokeStyle = options.medianColor;\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(x0, props.median);\n      ctx.lineTo(x0 + width, props.median);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.restore();\n      ctx.save();\n\n      if (options.lowerBackgroundColor && options.lowerBackgroundColor !== 'transparent' && options.lowerBackgroundColor !== '#0000') {\n        ctx.fillStyle = options.lowerBackgroundColor;\n\n        if (props.q3 > props.q1) {\n          ctx.fillRect(x0, props.median, width, props.q3 - props.median);\n        } else {\n          ctx.fillRect(x0, props.median, width, props.q1 - props.median);\n        }\n      }\n\n      ctx.restore();\n\n      if (props.q3 > props.q1) {\n        ctx.strokeRect(x0, props.q1, width, props.q3 - props.q1);\n      } else {\n        ctx.strokeRect(x0, props.q3, width, props.q1 - props.q3);\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(x0, props.whiskerMin);\n      ctx.lineTo(x0 + width, props.whiskerMin);\n      ctx.moveTo(x, props.whiskerMin);\n      ctx.lineTo(x, props.q1);\n      ctx.moveTo(x0, props.whiskerMax);\n      ctx.lineTo(x0 + width, props.whiskerMax);\n      ctx.moveTo(x, props.whiskerMax);\n      ctx.lineTo(x, props.q3);\n      ctx.closePath();\n      ctx.stroke();\n    }\n\n    _drawBoxPlotHorizontal(ctx) {\n      const {\n        options\n      } = this;\n      const props = this.getProps(['y', 'height', 'q1', 'q3', 'median', 'whiskerMin', 'whiskerMax']);\n      const {\n        y\n      } = props;\n      const {\n        height\n      } = props;\n      const y0 = y - height / 2;\n\n      if (props.q3 > props.q1) {\n        ctx.fillRect(props.q1, y0, props.q3 - props.q1, height);\n      } else {\n        ctx.fillRect(props.q3, y0, props.q1 - props.q3, height);\n      }\n\n      ctx.save();\n\n      if (options.medianColor && options.medianColor !== 'transparent') {\n        ctx.strokeStyle = options.medianColor;\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(props.median, y0);\n      ctx.lineTo(props.median, y0 + height);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.restore();\n      ctx.save();\n\n      if (options.lowerBackgroundColor && options.lowerBackgroundColor !== 'transparent') {\n        ctx.fillStyle = options.lowerBackgroundColor;\n\n        if (props.q3 > props.q1) {\n          ctx.fillRect(props.median, y0, props.q3 - props.median, height);\n        } else {\n          ctx.fillRect(props.median, y0, props.q1 - props.median, height);\n        }\n      }\n\n      ctx.restore();\n\n      if (props.q3 > props.q1) {\n        ctx.strokeRect(props.q1, y0, props.q3 - props.q1, height);\n      } else {\n        ctx.strokeRect(props.q3, y0, props.q1 - props.q3, height);\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(props.whiskerMin, y0);\n      ctx.lineTo(props.whiskerMin, y0 + height);\n      ctx.moveTo(props.whiskerMin, y);\n      ctx.lineTo(props.q1, y);\n      ctx.moveTo(props.whiskerMax, y0);\n      ctx.lineTo(props.whiskerMax, y0 + height);\n      ctx.moveTo(props.whiskerMax, y);\n      ctx.lineTo(props.q3, y);\n      ctx.closePath();\n      ctx.stroke();\n    }\n\n    _getBounds(useFinalPosition) {\n      const vert = this.isVertical();\n\n      if (this.x == null) {\n        return {\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0\n        };\n      }\n\n      if (vert) {\n        const {\n          x,\n          width,\n          whiskerMax,\n          whiskerMin\n        } = this.getProps(['x', 'width', 'whiskerMin', 'whiskerMax'], useFinalPosition);\n        const x0 = x - width / 2;\n        return {\n          left: x0,\n          top: whiskerMax,\n          right: x0 + width,\n          bottom: whiskerMin\n        };\n      }\n\n      const {\n        y,\n        height,\n        whiskerMax,\n        whiskerMin\n      } = this.getProps(['y', 'height', 'whiskerMin', 'whiskerMax'], useFinalPosition);\n      const y0 = y - height / 2;\n      return {\n        left: whiskerMin,\n        top: y0,\n        right: whiskerMax,\n        bottom: y0 + height\n      };\n    }\n\n  }\n\n  BoxAndWiskers.id = 'boxandwhiskers';\n  BoxAndWiskers.defaults = { ...chart_js.BarElement.defaults,\n    ...baseDefaults,\n    medianColor: 'transparent',\n    lowerBackgroundColor: 'transparent'\n  };\n  BoxAndWiskers.defaultRoutes = { ...chart_js.BarElement.defaultRoutes,\n    ...baseRoutes\n  };\n\n  class Violin extends StatsBase {\n    draw(ctx) {\n      ctx.save();\n      ctx.fillStyle = this.options.backgroundColor;\n      ctx.strokeStyle = this.options.borderColor;\n      ctx.lineWidth = this.options.borderWidth;\n      const props = this.getProps(['x', 'y', 'width', 'height', 'min', 'max', 'coords', 'maxEstimate']);\n      helpers.drawPoint(ctx, {\n        pointStyle: 'rectRot',\n        radius: 5,\n        borderWidth: this.options.borderWidth\n      }, props.x, props.y);\n\n      if (props.coords && props.coords.length > 0) {\n        this._drawCoords(ctx, props);\n      }\n\n      this._drawOutliers(ctx);\n\n      this._drawMeanDot(ctx);\n\n      ctx.restore();\n\n      this._drawItems(ctx);\n    }\n\n    _drawCoords(ctx, props) {\n      ctx.beginPath();\n\n      if (this.isVertical()) {\n        const {\n          x,\n          width\n        } = props;\n        const factor = width / 2 / props.maxEstimate;\n        ctx.moveTo(x, props.min);\n        props.coords.forEach(c => {\n          ctx.lineTo(x - c.estimate * factor, c.v);\n        });\n        ctx.lineTo(x, props.max);\n        ctx.moveTo(x, props.min);\n        props.coords.forEach(c => {\n          ctx.lineTo(x + c.estimate * factor, c.v);\n        });\n        ctx.lineTo(x, props.max);\n      } else {\n        const {\n          y,\n          height\n        } = props;\n        const factor = height / 2 / props.maxEstimate;\n        ctx.moveTo(props.min, y);\n        props.coords.forEach(c => {\n          ctx.lineTo(c.v, y - c.estimate * factor);\n        });\n        ctx.lineTo(props.max, y);\n        ctx.moveTo(props.min, y);\n        props.coords.forEach(c => {\n          ctx.lineTo(c.v, y + c.estimate * factor);\n        });\n        ctx.lineTo(props.max, y);\n      }\n\n      ctx.closePath();\n      ctx.stroke();\n      ctx.fill();\n    }\n\n    _getBounds(useFinalPosition) {\n      if (this.isVertical()) {\n        const {\n          x,\n          width,\n          min,\n          max\n        } = this.getProps(['x', 'width', 'min', 'max'], useFinalPosition);\n        const x0 = x - width / 2;\n        return {\n          left: x0,\n          top: max,\n          right: x0 + width,\n          bottom: min\n        };\n      }\n\n      const {\n        y,\n        height,\n        min,\n        max\n      } = this.getProps(['y', 'height', 'min', 'max'], useFinalPosition);\n      const y0 = y - height / 2;\n      return {\n        left: min,\n        top: y0,\n        right: max,\n        bottom: y0 + height\n      };\n    }\n\n  }\n\n  Violin.id = 'violin';\n  Violin.defaults = { ...chart_js.BarElement.defaults,\n    ...baseDefaults\n  };\n  Violin.defaultRoutes = { ...chart_js.BarElement.defaultRoutes,\n    ...baseRoutes\n  };\n\n  function patchController(type, config, controller) {\n    let elements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let scales = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    chart_js.registry.addControllers(controller);\n\n    if (Array.isArray(elements)) {\n      chart_js.registry.addElements(...elements);\n    } else {\n      chart_js.registry.addElements(elements);\n    }\n\n    if (Array.isArray(scales)) {\n      chart_js.registry.addScales(...scales);\n    } else {\n      chart_js.registry.addScales(scales);\n    }\n\n    const c = config;\n    c.type = type;\n    return c;\n  }\n\n  class BoxPlotController extends StatsBase$1 {\n    _parseStats(value, config) {\n      return asBoxPlotStats(value, config);\n    }\n\n    _transformStats(target, source, mapper) {\n      super._transformStats(target, source, mapper);\n\n      for (const key of ['whiskerMin', 'whiskerMax']) {\n        target[key] = mapper(source[key]);\n      }\n    }\n\n  }\n\n  BoxPlotController.id = 'boxplot';\n  BoxPlotController.defaults = helpers.merge({}, [chart_js.BarController.defaults, baseDefaults$1(boxOptionsKeys), {\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: chart_js.BarController.defaults.animations.numbers.properties.concat(['q1', 'q3', 'min', 'max', 'median', 'whiskerMin', 'whiskerMax', 'mean'], boxOptionsKeys.filter(c => !c.endsWith('Color')))\n      }\n    },\n    dataElementType: BoxAndWiskers.id\n  }]);\n  BoxPlotController.overrides = helpers.merge({}, [chart_js.BarController.overrides, defaultOverrides()]);\n\n  class BoxPlotChart extends chart_js.Chart {\n    constructor(item, config) {\n      super(item, patchController('boxplot', config, BoxPlotController, BoxAndWiskers, [chart_js.LinearScale, chart_js.CategoryScale]));\n    }\n\n  }\n\n  BoxPlotChart.id = BoxPlotController.id;\n\n  class ViolinController extends StatsBase$1 {\n    _parseStats(value, config) {\n      return asViolinStats(value, config);\n    }\n\n    _transformStats(target, source, mapper) {\n      super._transformStats(target, source, mapper);\n\n      target.maxEstimate = source.maxEstimate;\n\n      if (Array.isArray(source.coords)) {\n        target.coords = source.coords.map(c => ({ ...c,\n          v: mapper(c.v)\n        }));\n      }\n    }\n\n  }\n\n  ViolinController.id = 'violin';\n  ViolinController.defaults = helpers.merge({}, [chart_js.BarController.defaults, baseDefaults$1(baseOptionKeys), {\n    points: 100,\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: chart_js.BarController.defaults.animations.numbers.properties.concat(['q1', 'q3', 'min', 'max', 'median', 'maxEstimate'], baseOptionKeys.filter(c => !c.endsWith('Color')))\n      },\n      kdeCoords: {\n        fn: interpolateKdeCoords,\n        properties: ['coords']\n      }\n    },\n    dataElementType: Violin.id\n  }]);\n  ViolinController.overrides = helpers.merge({}, [chart_js.BarController.overrides, defaultOverrides()]);\n\n  class ViolinChart extends chart_js.Chart {\n    constructor(item, config) {\n      super(item, patchController('violin', config, ViolinController, Violin, [chart_js.LinearScale, chart_js.CategoryScale]));\n    }\n\n  }\n\n  ViolinChart.id = ViolinController.id;\n  chart_js.registry.addControllers(BoxPlotController, ViolinController);\n  chart_js.registry.addElements(BoxAndWiskers, Violin);\n  exports.BoxAndWiskers = BoxAndWiskers;\n  exports.BoxPlotChart = BoxPlotChart;\n  exports.BoxPlotController = BoxPlotController;\n  exports.StatsBase = StatsBase;\n  exports.Violin = Violin;\n  exports.ViolinChart = ViolinChart;\n  exports.ViolinController = ViolinController;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}